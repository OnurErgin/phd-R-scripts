{
    "collab_server" : "",
    "contents" : "# 24/03/2015\n\n######\n#ToDo: Try three candidates for refnode selection\n#      Find the limitations through RSS-curve, how right can one go on the curve, \n#        what RSS is still doable?\n#\n\ncols <- Nx <- 10; rows <- Ny <- 5; dx <- 3; dy <- 3; sd_noise_dbm <- -30\n\nexperimentSet <- 1:100 # 3x3fails: c(8, 16, 34, 54, 59, 83, 90) # 5x5fails: c(8, 34, 41, 59, 81, 83, 90)\nTruth <- matrix (c(0:(Nx*Ny-1)), nrow=Ny, byrow=TRUE)\nrefnodes <- c(Truth[1,1],Truth[Ny,1])\n#refnodes <- c(Truth[1,1],Truth[2,1])\n\nnumnodes <- length(Truth)\n#directory <- paste(\"./simOut-\",Nx,\"x\",Ny,\"-\",dx,\"mX\",dy,\"m-Noise\",sd_noise_dbm,\"dbm/\",sep=\"\")\n#basedirectory <- \"inputs_simulation/equiDist/3x3_ideal/\"; subdirectory<-\"\"\nbasedirectory <- \"./equiDist/\" # For Carme\n#basedirectory <- \"/Volumes/carme_lhome/R/2d/equiDist/\"\nsubdirectory <- paste(\"simOut-\",Nx,\"x\",Ny,\"-\",dx,\"mX\",dy,\"m-Noise\",sd_noise_dbm,\"dbm/\",sep=\"\")\n#basedirectory <- paste(\"../measurements/simOut-\",Nx,\"x\",Ny,\"-\",dx,\"mX\",dy,\"m-Noise\",sd_noise_dbm,\"dbm/\",sep=\"\");  subdirectory<-\"\" #\"../measurements/simOut-5x4-3mX3m-Noise-30dbm/\";\ndirectory <- paste(basedirectory,subdirectory,sep=\"\")\n\nsource(\"EdgeDiscovery.R\")\n\npruneThreshold <- 2\nsource(\"probSeqFunctions-fixedPrune.R\")\n\ntopQuantile <- 0.5\nrssMaxDifference <- 3 \n\nrun.verbose <- FALSE\nproduceOutput <- FALSE # for probabilitySeqDF and probabilitiesDF. This file will produce output anyways\n\nexpSize <- length(experimentSet)\nverdicts <- data.frame(expNo=numeric(expSize), verdict=logical(expSize), reliability=character(expSize), stringsAsFactors=FALSE)\nhighReliable <- mediumReliable <- lowReliable <- c()\ntotalSuccess <- 0\nfailedExpNos <- c()\nlostCandidateToCompetitor <- c()\nfor(expNo in experimentSet)\n{   \n  startTime <- proc.time()\n  \n  TRACE_FILE <- paste(directory,\"2dSim-\",Nx,\"x\",Ny,\"-\",dx,\"mX\",dy,\"m-\",expNo,\".txt\",sep=\"\")\n  cat(\"Loading:\",TRACE_FILE, \"\\n\")  \n  packets <- read.table(TRACE_FILE,  na.strings=\"\", header=TRUE)\n  packets$time  <- 0\n  packets$power <- 0\n  \n  #refNodeSet <- getFirstColumnRefs.adjacentRefNodes(refnodes, packets, Ny)  \n  refNodeSet <- getFirstColumnRefs(refnodes, packets, Ny)  \n  #refNodeSet <- as.character(c(0,5,10,15))\n\n  print(refNodeSet)\n  nrowsResult <- length(refNodeSet); ncolsResult <- ceiling(numnodes/length(refNodeSet))\n  result <- matrix(data=-1,nrow=nrowsResult, ncol=ncolsResult)\n  \n  result[,1] <- refNodeSet # place refnodes in place: along the 1st column\n  # Row-by-row select the next node at each column\n  for (ci in 2:ncolsResult){ # for each column\n    for (ri in 1:nrowsResult){ # for each row; only odds: which(1:Ny %% 2 == 1)\n     # if (ci == 3) browser()\n      if (result[ri,ci] != -1) next;\n      if (FALSE){\n      winners <- getSendersWinningReceivers(allPackets=packets, theSender=result[ri,(ci-1)], excludeSet <- as.integer(result))\n      closestNode <- mostFreqReceiver(winners,tIndex=1)\n      if (is.null(closestNode)) \n        closestNode <- -1\n      #cat (closestNode, \"with P=\", findProbability(winners[1,], 1, length(winners[1,])),\"\\n\")\n      if (ri + 1 <= nrowsResult) { # if next row exists\n        #####\n        closestNodeP <- findProbabilityByName(winners[1,],name=closestNode)\n        secondClosestNode <- mostFreqReceiver(winners,tIndex=2)\n      \n        nextNodeWinners <- getSendersWinningReceivers(allPackets=packets, theSender=result[ri+1,(ci-1)], excludeSet <- as.integer(result))\n        closestNodeForNextNode <- mostFreqReceiver(nextNodeWinners,tIndex=1)\n        closestNodeForNextNodeP <- findProbabilityByName(nextNodeWinners[1,],name=closestNodeForNextNode)\n        \n        if (closestNodeForNextNode != closestNode) {\n          result[ri,ci] <- closestNode \n        }else \n        if (closestNodeForNextNode == closestNode) {\n          if (closestNodeP >= closestNodeForNextNodeP) {\n            result[ri,ci] <- closestNode \n          } else {\n            result[ri+1,ci] <- closestNodeForNextNode # ?= closestNode\n            # Select a new one\n            winners <- getSendersWinningReceivers(allPackets=packets, theSender=result[ri,(ci-1)], excludeSet <- as.integer(result))\n            closestNode <- mostFreqReceiver(winners,tIndex=1)\n            \n            if (is.null(closestNode)) \n              closestNode <- -1\n              \n              result[ri,ci] <- closestNode \n            \n            print(\"Lost candidate to Competitor\"); lostCandidateToCompetitor <- c(lostCandidateToCompetitor, expNo)\n          }\n        }\n        \n        #####\n      } else {\n        result[ri,ci] <- closestNode \n      } #if ...\n      } #if FALSE\n      else { # Version 2\n      winners <- getSendersWinningReceivers(allPackets=packets, theSender=result[ri,ci-1], excludeList=as.integer(result))\n      candidates1 <- c(mostFreqReceiver(winners,tIndex=1),mostFreqReceiver(winners,tIndex=2))\n      candidates1P <- c(findProbabilityByName(winners[1,],candidates1[1]),findProbabilityByName(winners[1,],candidates1[2]))\n      \n      if (ri +1 <= nrowsResult){ # if there is a row down below\n        winners2 <- getSendersWinningReceivers(allPackets=packets, theSender=result[ri+1,ci-1], excludeList=as.integer(result))\n        candidates2 <- c(mostFreqReceiver(winners2,tIndex=1),mostFreqReceiver(winners2,tIndex=2))\n        candidates2P <- c(findProbabilityByName(winners2[1,],candidates2[1]),findProbabilityByName(winners2[1,],candidates2[2]))\n        \n        \n        if(sum(is.na(candidates1P)) == 0) # if \n          if(candidates1P[1]==candidates1P[2] ){\n            result[ri+1,ci] <- candidates2[1]\n            \n            winners <- getSendersWinningReceivers(allPackets=packets, theSender=result[ri,ci-1], excludeList=as.integer(result))\n            candidates1 <- mostFreqReceiver(winners,tIndex=1)\n            #candidates1P <- findProbabilityByName(winners[1,],candidates1)\n            rm(\"candidates2\")\n          }\n      }\n      result[ri,ci] <- candidates1[1]\n      rm(\"candidates1\",\"winners\")\n      }\n    }\n  }\n  class(result) <- \"integer\"\n  \n  if (all.equal(Truth,result) == TRUE) {\n    totalSuccess <- totalSuccess + 1\n    isSuccess <- TRUE\n  } else {\n    failedExpNos <- c(failedExpNos,expNo)\n    isSuccess <- FALSE\n    print(result)\n  }\n  cat(\"Result is \", isSuccess, \"\\t total: \",totalSuccess, \"/\",length(failedExpNos)+totalSuccess, \"\\n\")\n  \n  ## Print Elapsed Time\n  endTime <- proc.time()\n  print(endTime-startTime)\n\n  outputToFile <- TRUE\n  outDir <- \"results-2CornerRef/\"\n  outputDirectory <- paste(directory,outDir,sep=\"\")\n  \n  if (!file.exists(outputDirectory) && outputToFile)\n    dir.create(outputDirectory,showWarnings=TRUE,recursive=TRUE)\n  \n  if(outputToFile){\n    outFile <- paste(outputDirectory,\"result-\",Nx,\"x\",Ny,\"-\",dx,\"mX\",dy,\"m-\",expNo,\".txt\",sep=\"\")\n    write.table(result, outFile, row.names=FALSE, col.names = FALSE)\n  }\n  \n  if(outputToFile){\n    outFile <- paste(outputDirectory,\"success-\",Nx,\"x\",Ny,\"-\",dx,\"mX\",dy,\"m\",\".txt\",sep=\"\")\n    write.table(totalSuccess, outFile, row.names=FALSE, col.names = FALSE)\n  }\n  \n  if (FALSE){\n        ## Reliability\n        score <- 0\n        # First column reverse:\n        revRefNodeSet <- getFirstColumnRefs(rev(refnodes),packets, Ny)\n        if (TRUE == all.equal(rev(refNodeSet),revRefNodeSet)) {\n          print(\"First column matches\")\n          score <- score + 1\n        }\n        \n        if (-1 %in% result) {\n          score <- 0\n          } else { cols <- ncolsResult ; rows <- nrowsResult\n            \n            lastColumn <- result[,cols]\n            \n            lastColumnRefnodes <- c(result[1,cols], result[rows,cols])\n            lastColumnRefnodeset <- getFirstColumnRefs(lastColumnRefnodes, packets, Ny)\n            reverseLastColumnRefnodeset <- getFirstColumnRefs(rev(lastColumnRefnodes), packets, Ny)\n              \n            if (TRUE == all.equal(as.integer(lastColumnRefnodeset),lastColumn) || \n                  TRUE == all.equal(as.integer(reverseLastColumnRefnodeset),lastColumn) ){\n                print(\"Last column matches\")\n                score <- score + 1\n                \n                if (TRUE == all.equal(lastColumnRefnodeset,rev(reverseLastColumnRefnodeset)))\n                  score <- score + 1\n            }\n          }\n        \n        if (score == 3)\n        {\n          highReliable <- c( highReliable , expNo)\n          cat(\"ExpNo:\",expNo,\" reliability is: High!\\n\")\n          reliability <- \"high\"\n        } else if (score == 2){\n          mediumReliable <- c(mediumReliable, expNo)\n          cat(\"ExpNo:\",expNo,\" reliability is: Medium!\\n\")\n          reliability <- \"medium\"\n        } else {\n          lowReliable <- c(lowReliable, expNo)\n          cat(\"ExpNo:\",expNo,\" reliability is: Low!\\n\")\n          reliability <- \"low\"\n        }\n        \n        verdicts[expNo,\"expNo\"] <- expNo\n        verdicts[expNo,\"verdict\"] <- isSuccess\n        verdicts[expNo,\"reliability\"] <- reliability\n        print(tail(verdicts[verdicts$expNo!=0,],n=1))\n        ## Reliability:\n        #First column (fc) ref nodes match reverse (rfc)\n        #Last column(lc) in refnode check = lr\n        #Last column reverse refnode check = lrr\n        #Lastcolumn in lr or lrr\n        \n        # if (fc == rfc && lc %in% c(lr,lrr))\n        #   if (lr==lrr) then high\n        #   else medium\n        # 3 comparisons. 3 matches = high, 2 matches = medium, less matches = low reliablity\n        #   1: fc == rfc\n        #   2: lc %in% c(lr,lrr)\n        #   3: lr==lrr\n        \n  } # if (FALSE) Reliability\n  \n} # for expNo\n\ncat(\"totalSuccess=\",totalSuccess,\"/\",length(experimentSet) ,\"\\n\")\ncat(\"High Reliable = \", length(highReliable), \"\\n\")\ncat(\"Medium Reliable = \", length(mediumReliable), \"\\n\")\ncat(\"Low Reliable = \", length(lowReliable), \"\\n\")\n\nif(FALSE)\n{\n  outfile <- paste(directory,\"verdict-\",length(refnodes),\"refs-\",Nx,\"x\",Ny,\"-\",dx,\"mX\",dy,\"m-Noise\",sd_noise_dbm,\"dbm.txt\",sep=\"\")\n  write.table(verdicts, file=outfile, sep=\" \", col.names=TRUE, row.names=FALSE)\n  cat(outfile, \" written.\\n\")\n}\n",
    "created" : 1433024957484.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "65|17|105|6|\n165|13|228|2|\n",
    "hash" : "1499450660",
    "id" : "E37F8939",
    "lastKnownWriteTime" : 1436534633,
    "last_content_update" : 0,
    "path" : "~/phd/R/2d/equiDistance2D.R",
    "project_path" : "equiDistance2D.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 24,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}