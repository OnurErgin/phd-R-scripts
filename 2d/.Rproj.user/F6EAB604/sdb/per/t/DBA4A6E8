{
    "collab_server" : "",
    "contents" : "#source(\"userFunctions.R\")\n\nlibrary(plyr)\n\nMatrixRowSize <- 5040   # 7!=5040\n\n#rm(\"getSendersWinningReceivers\")\n\n## Load Functions\nmostFreqReceiver <- function (valueSet, tIndex=1) { mfr <- names(rev(sort(table(valueSet)))[tIndex]); return(mfr) }\nfindProbability <- function (valueSet, tIndex=1, setLength) { rev(sort(table(valueSet)))[tIndex]/setLength }\nfindProbabilityByName <- function (valueSet, name){table(valueSet[as.character(name)])/length(valueSet)}\nfindWeight <- function(placedReceivers, weightSet) { ix<-(placedReceivers+1); return(weightSet[ix]) }\n\ncomputeProbabilities <- function (probDF, vRows){\n  probs <- c()\n  for(rr in 1:vRows)\n  {\n    prob <- 1\n    if (TRUE)\n      for (cc in 1:ncol(probDF))\n      {\n        #cat(\" probabilitiesDF[\",rr,\",\",cc,\"]=\",probabilitiesDF[rr,cc], sep=\"\")\n        prob <- prob * probDF[rr,cc]\n      }\n    prob <- prod(probDF[rr,])\n    #print(\"\\n\")\n    probs <- c(probs,prob)\n    #cat(\"probabilitySeqDF[\",rr,\",prob] <- \",prob,\"=>\",probabilitySeqDF[rr,\"prob\"],\"\\n\",sep=\"\")\n  }\n  #print(probabilitySeqDF[1:validRows,]); #print(probabilitiesDF)\n  return(probs)\n}\n\n\n# Instead of comparing all rssi's, below function compares mean(Q90) rssi's for each channel\ngetSendersWinningReceivers <- function (allPackets, theSender, excludeList=NULL, includeList=NULL) {\n  \n  if (is.null(excludeList) && is.null(includeList)) \n  {\n    thisFunctionsName <- match.call()[[1]]\n    stop (paste(\"In \", thisFunctionsName,\", excludeList and includeList cannot be both NULL!\"))\n  } \n  else if (!is.null(excludeList) && !is.null(includeList)) \n  {\n    thisFunctionsName <- match.call()[[1]]\n    stop (paste(\"In \", thisFunctionsName,\", excludeList and includeList cannot be both non-NULL!\"))\n  } \n  else if (!is.null(excludeList)) \n    senderPackets <- subset(allPackets, sender == theSender & !(receiver %in% excludeList), select=c(-time,-power)) \n  else if (!is.null(includeList))\n    senderPackets <- subset(allPackets, sender == theSender & (receiver %in% includeList), select=c(-time,-power))\n  \n  if (!exists(\"senderPackets\") || nrow(senderPackets)==0) {\n    cat(paste(\"No packets found from sender\",theSender,\"to receivers:\",paste(excludeList,sep=','),paste(includeList,sep=',')))\n    # Above was stop(...), below was not there\n    return(NA)\n  }\n  \n  channelSet <- unique(packets$channel)\n  \n  senderPackets <- ddply(senderPackets, .(receiver,sender,channel), summarize, rssiQuantileMean=mean(subset(rssi, rssi>=quantile(rssi, topQuantile))) )\n  \n  sendersWinningReceivers <- c()\n  channelsOfWinningReceivers <- c()\n  for (c in channelSet) \n  {\n      sendersNthPackets <- subset(senderPackets,channel==c)   # find all reports for {s, c, n}\n      theWinningReceiver <- -9999 #impossible receiver\n      \n      #rssMaxDifference <- 2 # now in configuration.R\n      rssDifference <- 0\n      \n      firstRssiDummy <- -1000\n      firstRssi <- firstRssiDummy # impossible rssi, so 1st iteration of loop actuates\n      \n      while (rssDifference <= rssMaxDifference)\n      {\n        sendersNthPackets <- subset(sendersNthPackets, receiver!=theWinningReceiver)\n        if (nrow(sendersNthPackets) == 0) # if there was only one receiver, strange measurement!.\n          break\n        sendersNthPackets <- sendersNthPackets[order(-sendersNthPackets[,\"rssiQuantileMean\"]),]  # reorder by rssi, big to small\n        \n        theWinningReceiver <- as.numeric(as.character(sendersNthPackets[1,\"receiver\"])) # find the receiver with best rssi\n        theWinningRssi <- as.numeric(as.character(sendersNthPackets[1,\"rssiQuantileMean\"])) # find the rssi of the best receiver\n        \n        rssDifference <- firstRssi - theWinningRssi\n        #cat(\"rssDifference=\",rssDifference, \"firstRssi=\",firstRssi, \"theWinningRssi=\",theWinningRssi,\"theWinningReceiver=\",theWinningReceiver , \"at c =\",c,\"n =\",n,\"for sender:\",s,\"\\n\")\n        \n        if(rssDifference <= rssMaxDifference)\n        {\n          sendersWinningReceivers <- c(sendersWinningReceivers,theWinningReceiver) # put it into the list.\n          channelsOfWinningReceivers <- c(channelsOfWinningReceivers,c)\n          \n          if (firstRssi != firstRssiDummy && FALSE)\n          {\n            cat(\"rssDifference=\",rssDifference, \"firstRssi=\",firstRssi, \"theWinningRssi=\",theWinningRssi,\"theWinningReceiver=\",theWinningReceiver , \"at c =\",c,\"for sender:\",s,\"\\n\")\n            cat (\"Just inserted\", theWinningReceiver,\":\",theWinningRssi,\"\\n\")\n          }\n        }\n        else\n          next\n        \n        if (firstRssi == firstRssiDummy)  # set just once\n          firstRssi <- theWinningRssi\n      }\n      \n      if (c==13 && FALSE)\n      {stop (\"Stopped after c=13\"); warning (\"warning iste.\")}\n    \n    \n  } # for c\n  sendersWinningReceivers <- sendersWinningReceivers[!is.na(sendersWinningReceivers)]   # remove NAs\n  #return (sendersWinningReceivers)\n  return(matrix(c(sendersWinningReceivers,channelsOfWinningReceivers),nrow=2,byrow=TRUE, dimnames=list(c(\"receiver\",\"channel\"),NULL)))\n}\n\n\nfindProbSequences <- function (packets, refnode, produceOutput=FALSE, verbose = FALSE)\n{\n  # Verbose functions\n  vPrint <- function (arg) { if (verbose) print(arg) }\n  vCat <- function (...) { if (verbose) cat(...) }\n  \n  # Create two parallel matrices\n  probabilitySeqMatrix <- matrix(data = NA, nrow = MatrixRowSize, ncol = numnodes+1, byrow = TRUE, dimnames = list(NULL,c(paste(\"N\",1:numnodes,sep=\"\"),\"P\")))\n  probabilitiesMatrix <- matrix(data = 1, nrow = MatrixRowSize, ncol = numnodes, byrow = TRUE, dimnames = list(NULL,paste(\"P\",1:numnodes,sep=\"\")))\n  \n  probabilitySeqDF <- as.data.frame(probabilitySeqMatrix)\n  probabilitiesDF <- as.data.frame(probabilitiesMatrix)\t\n  \n  probabilitySeqDF[1,1] <- refnode\n  probabilitiesDF[1,1] <- 1\n  validRows <- 1\n  lastRow <- 1\n  \n  probabilitySeqDF[1,\"P\"] <- 1\n  \n  # For returning error \"-1\". \"0\" cannot be returned anymore since it was used in the Simulation NodeIDs\n  allError <- probabilitySeqDF[1:2,]\n  allError$prob <- 4\n  allError[1,] <- rep(-1,ncol(allError))\n  allError[2,] <- rep(-1,ncol(allError))\n#   allZeros <- probabilitySeqDF[1:2,]\n#   allZeros$prob <- 4\n#   allZeros[1,] <- rep(0,ncol(allZeros))\n#   allZeros[2,] <- rep(0,ncol(allZeros))\n\n  \n  ## Progress Bar\n  #\n#   cat(\"\\n\"); \n#   pb <- txtProgressBar(min = 0, max = numnodes, style = 3)\n  ##\\\n  \n  for (nextnode in 1:(numnodes-1)) #For each position\n  {\n    # Cut off the sequences here: after 5th node, take the best subseq and continue from there.\n    \n    #maxSubSeqSize <- 5 # now in configuration.R\n    if (nextnode %% maxSubSeqSize == 0) # Start Clustering\n    {\n      #cluster()\n      vPrint(\"clustering\")\n      \n      #print (probabilitiesDF[1:validRows,])\n      vPrint (probabilitySeqDF[1:validRows,])\n      #cat(\"Paused.. Hit Enter to continue\"); scan(n=1)\n      probabilitySeqDF$P[1:validRows] <- computeProbabilities(probabilitiesDF,validRows)\n      \n      maxProb <- max(probabilitySeqDF$P, na.rm=TRUE)\n      \n      #selectedRows <- probabilitySeqDF$P>=(maxProb/2)\n      selectedRows <- probabilitySeqDF$P[1:validRows]>=(maxProb/2)\n      newValidRows <- sum(selectedRows)\n      \n      minimum.number.of.rows.to.keep <- 2\n      if(newValidRows < minimum.number.of.rows.to.keep){\n        selectedRows[1:minimum.number.of.rows.to.keep] <- TRUE\n        newValidRows <- sum(selectedRows)\n      }\n      \n      vCat(\"Cut down from\", validRows, \"to\",newValidRows, \"rows.\")\n      \n      if (FALSE && 10 %in% probabilitySeqDF$N2 && !(10 %in% probabilitySeqDF[selectedRows,]$N2)) {\n        browser(\"hello!\"); vPrint (probabilitySeqDF[1:validRows,])\n      }\n      \n      selectedRows <- c(selectedRows,rep(TRUE,nrow(probabilitySeqDF)-length(selectedRows)))\n      \n      #This code removes undesired rows, resulting in a reduced size of DFs\n      probabilitiesDF <- probabilitiesDF[selectedRows,]\n      probabilitySeqDF <- probabilitySeqDF[selectedRows,]\n      \n      validRows <- newValidRows\n      \n    } # Finish Clustering\n    \n    ## UPDATE Progress Bar\n    #\n    vCat(\"\\n\"); \n    pb <- txtProgressBar(min = 0, max = numnodes, style = 3)\n    ##\n    \n    lastRow <- validRows\n    for (Row in lastRow:1) \n    {\n      s <- probabilitySeqDF[Row,nextnode]\n      #cat(\"\\nRow: \", Row, \", s: \",s, \"\\n\",sep=\"\"); print(probabilitySeqDF[Row,])\n      \n      #ErrorCheck\n      if (is.na(s)) return (allError)      \n      \n      if (probabilitiesDF[Row,1] == 0)\n        next\n      \n      if (nextnode == (numnodes-2) && FALSE) {  ##  ... Ni Nj] Nk Nl ==> P(NjNk) = P(NiNk)*P(NjNk) , totally heuristical.\n        lastNodes <- subset(packets, sender == s & !(receiver %in% probabilitySeqDF[Row,1:nextnode]), select=c(receiver))\n        \n        lastPlacedNode <- probabilitySeqDF[Row,nextnode]\n        excludeList <- probabilitySeqDF[Row,c(1:nextnode)]\n        \n        \n        ## Last Sender\n        lastSendersReceivers <- c()\n        lastSendersReceivers <- getSendersWinningReceivers(packets, theSender = lastPlacedNode, excludeList=excludeList)[\"receiver\",]\n        lastSendersReceivers <- lastSendersReceivers[!is.na(lastSendersReceivers)]  \n        freqTable1 <- table(lastSendersReceivers)\n        \n        ## Previous Sender\n        prevSender <- probabilitySeqDF[Row,nextnode-1]\n        prevSendersReceivers <- c()\n        prevSendersReceivers <- getSendersWinningReceivers(packets, theSender = prevSender, excludeList=excludeList)[\"receiver\",]\n        prevSendersReceivers <- prevSendersReceivers[!is.na(prevSendersReceivers)]  \n        \n        freqTable2 <- table(prevSendersReceivers)\n        \n        vPrint (\"BEFORE\")\n        vCat (\"LastNode:\",lastPlacedNode,\"\\n\")\n        vPrint(freqTable1)\n        vCat(\"PreviousNode:\", prevSender,\"\\n\")\n        vPrint(freqTable2)\n        vPrint(probabilitySeqDF[1:validRows,]); vCat(\"\\b (\",validRows,\" rows)\\n\",sep=\"\")\n        vPrint(probabilitiesDF[1:validRows,]); vCat(\"\\b (\",validRows,\" rows)\\n\",sep=\"\")\n        rcvrNo <- 1\n        for (r in unique(lastSendersReceivers))\n        {\n          pr1 <- freqTable1[as.character(r)]/sum(freqTable1)\n          pr2 <- freqTable2[as.character(r)]/sum(freqTable2)\n          \n          if (rcvrNo == 1) \n          {\n            probabilitySeqDF[Row,nextnode+1] <- as.character(r)\n            probabilitiesDF[Row,nextnode+1] <- pr1*pr2\n            rcvrNo <- rcvrNo + 1\n          } \n          else \n          {\n            validRows <- validRows + 1\n            probabilitySeqDF[validRows,] <- c(probabilitySeqDF[Row,]) \n            probabilitiesDF[validRows,] <- c(probabilitiesDF[Row,])\n            \n            probabilityDFLastIndex <- validRows\n            probabilitySeqDF[probabilityDFLastIndex,nextnode+1] <- as.character(r)\n            \n            #find and compute probabilities here\n            nodeProbability <- pr1*pr2\n            probabilitiesDF[probabilityDFLastIndex,nextnode+1] <- nodeProbability \n          }\n          vPrint (\"AFTER\")\n          vPrint(probabilitySeqDF[1:validRows,]); vCat(\"\\b (\",validRows,\" rows)\\n\",sep=\"\")\n          vPrint(probabilitiesDF[1:validRows,]); vCat(\"\\b (\",validRows,\" rows)\\n\",sep=\"\")\n          \n        }\n        \n        \n      } \n      else \n        if (nextnode == (numnodes-1)) \n        {\n          ;# Put the remaining node right away and continue\n          #s <- probabilitySeqDF[Row,nextnode]\n          lastNode <- subset(packets, sender == s & !(receiver %in% probabilitySeqDF[Row,1:nextnode]), select=c(receiver))\n          \n          #cat(\"lastNode: \\n\"); print(unique(lastNode));\n          if(length(unique(lastNode)) > 1) \n          {\n            #cat(\"Error: lastNode size > 1 =\", length(unique(lastNode)))\n            vPrint(unique(lastNode))\n            next\t\n          }\n          \n          if(length(unique(lastNode)) == 1)\n          {\n            if (TRUE) # Put the last remaining node to the end with Np=1\n            {  \n              probabilitySeqDF[Row,nextnode+1] <- as.integer(as.character(lastNode[1,1])) #don't know why lastNode[1] doesn't work\n              probabilitiesDF[Row,nextnode+1] <- 1\n            }\n            else {\n              lastPlacedNode <- probabilitySeqDF[Row,nextnode]\n              \n              #remainingNode <- lastNode\n              #twoNodeBehind <- probabilitySeqDF[Row,nextnode-2]\n              #includeList <- c(remainingNode,twoNodeBehind)\n              twoNodeBehind <- nextnode-2  \n              excludeList <- probabilitySeqDF[Row,c(1:nextnode)[-twoNodeBehind]]\n              \n              sendersControlReceivers <- c()\n              \n              sendersControlReceivers <- getSendersWinningReceivers(packets, theSender = lastPlacedNode, excludeList=excludeList)[\"receiver\",]\n              \n              sendersControlReceivers <- sendersControlReceivers[!is.na(sendersControlReceivers)]\t\n              \n              remainingNode <- as.integer(as.character(lastNode[1,1]))  #don't know why lastNode[1] doesn't work\n              \n              freqTable <- table(sendersControlReceivers)\n              if (as.character(remainingNode) %in% names(freqTable))\n                pRemainingNode <- freqTable[names(freqTable)==as.character(remainingNode)]/sum(freqTable)\n              else\n                pRemainingNode <- 0\n              probabilitySeqDF[Row,nextnode+1] <- remainingNode\n              probabilitiesDF[Row,nextnode+1] <- pRemainingNode\n              vCat(\"P(\",lastPlacedNode,\"|\",probabilitySeqDF[Row,twoNodeBehind],\",\",remainingNode,\") =>\", \"P(\",lastPlacedNode,\"|\",remainingNode,\")=\",pRemainingNode,\"\\n\")\n            }\n          }\n          next\n          \n        }\n      \n      currentSequence <- probabilitySeqDF[Row,1:nextnode]\n      #find and compute probabilities here\n      \n      sendersWinningReceivers <- c()\n      \n      sendersWinningReceivers <- getSendersWinningReceivers(packets, theSender = s, excludeList=currentSequence)[\"receiver\",]\n        if(is.na(sendersWinningReceivers) || is.null(sendersWinningReceivers)) return(allError) # Error check\n      \n      sendersWinningReceivers <- sendersWinningReceivers[!is.na(sendersWinningReceivers)]\t\t  \t\n      \n      maxReceiver <- mostFreqReceiver(sendersWinningReceivers)\n      maxReceiverProb <- findProbability(sendersWinningReceivers,maxReceiver,length(sendersWinningReceivers[!is.na(sendersWinningReceivers)]))\n      \n      \n      # FOR EACH sendersWinningReceivers ADD A ROW AND UPDATE PROBABILITY\n      \n      #cat(\"Row=\",Row,\"nextnode=\",nextnode,\"UniqueReceivers of \", s, \" : \", unique(sendersWinningReceivers), \"\\n\")\n      \n      uniqueSenders<-unique(sendersWinningReceivers)\n      #cat(\"\\nAdd node:\", uniqueSenders[1])\n      #probabilitySeqDF[i,nextnode+1] <- uniqueSenders[1]\n      probabilitySeqDF[Row,nextnode+1] <- mostFreqReceiver(sendersWinningReceivers,1)\n      probabilitiesDF[Row,nextnode+1] <- findProbability(sendersWinningReceivers,1,length(sendersWinningReceivers[!is.na(sendersWinningReceivers)]))\n      \n      #probabilitySeqDF[Row,\"P\"] <- probabilitySeqDF[Row,\"P\"] * probabilitiesDF[Row,nextnode+1]\n      \n      vCat(\"\\nprobabilitySeqDF=\\n\");   vPrint(probabilitySeqDF[1:validRows,]); vCat(\"\\b (\",validRows,\" rows)\\n\",sep=\"\")\n      #print(probabilitiesDF[1:validRows,]); cat(\"\\b (\",validRows,\" rows)\\n\",sep=\"\")\n      \n      \n      if (length(unique(sendersWinningReceivers)) > 1)\n        for (r in 2:length(unique(sendersWinningReceivers)))\n        {\n          #probabilitySeqDF <- rbind(probabilitySeqDF, c(probabilitySeqDF[Row,])) #,receiversOfInterest[r])\t)\n          #probabilitiesDF <- rbind(probabilitiesDF, c(probabilitiesDF[Row,]))\n          validRows <- validRows + 1\n          probabilitySeqDF[validRows,] <- c(probabilitySeqDF[Row,]) #,receiversOfInterest[r])\t)\n          probabilitiesDF[validRows,] <- c(probabilitiesDF[Row,])\n          \n          #cat(\"Added Row:\",validRows,\"\\n\")\n          \n          #Depreciated: probabilityDFLastIndex <- nrow(probabilitySeqDF)\n          \n          probabilityDFLastIndex <- validRows\n          probabilitySeqDF[probabilityDFLastIndex,nextnode+1] <- mostFreqReceiver(sendersWinningReceivers,r)\n          \n          #find and compute probabilities here\n          nodeProbability <- findProbability(sendersWinningReceivers,r,length(sendersWinningReceivers[!is.na(sendersWinningReceivers)]))\n          probabilitiesDF[probabilityDFLastIndex,nextnode+1] <- nodeProbability\n          \n          #Update the probability\n          #probabilitySeqDF[probabilityDFLastIndex,\"prob\"] <- nodeProbability * probabilitySeqDF[probabilityDFLastIndex,\"prob\"]\n        }\n      \n      ## Progress Bar\n      #\n      progress <- (lastRow-Row)#*numnodes\n      setTxtProgressBar(pb, progress); vCat(\"\\n\"); \n      ##cat(\"Progress:\",progress,\"\\n\")\n      ##\n    }\n    \n  }\n  close(pb)\n  probabilitySeqDF$P[1:validRows] <- computeProbabilities(probabilitiesDF,validRows)\n  probabilitySeqDF$prob <- 0    #probability that's computed at the end\n  if (TRUE){\n    for(rr in 1:validRows)\n    {\n      prob <- 1\n      if (TRUE)\n        for (cc in 1:ncol(probabilitiesDF))\n        {\n          #cat(\" probabilitiesDF[\",rr,\",\",cc,\"]=\",probabilitiesDF[rr,cc], sep=\"\")\n          prob <- prob * probabilitiesDF[rr,cc]\n        }\n      prob <- prod(probabilitiesDF[rr,])\n      #print(\"\\n\")\n      probabilitySeqDF[rr,\"prob\"] <- prob\n      #cat(\"probabilitySeqDF[\",rr,\",prob] <- \",prob,\"=>\",probabilitySeqDF[rr,\"prob\"],\"\\n\",sep=\"\")\n    }\n    #print(probabilitySeqDF[1:validRows,]); #print(probabilitiesDF)\n  }\n  \n  if (produceOutput)\n  {\n    if (!file.exists(outputDirectory))\n      dir.create(outputDirectory,showWarnings=TRUE,recursive=TRUE)\n    \n    outFileName1 <- paste(outputDirectory,fileNamePrefix1,expNo,fileNameSuffix,sep=\"\")\n    write.table(probabilitySeqDF[1:validRows,], file=outFileName1, sep=\" \", append=FALSE, col.names=TRUE, row.names=FALSE)\n    \n    outFileName2 <- paste(outputDirectory,fileNamePrefix2,expNo,fileNameSuffix,sep=\"\")\n    write.table(probabilitiesDF[1:validRows,], file=outFileName2, sep=\" \", append=FALSE, col.names=TRUE, row.names=FALSE)\n    \n    cat(validRows,\"rows written to:\",outFileName1,\"and\",outFileName2,\"\\n\")\n  }\n  \n  probabilitySeqDF <- probabilitySeqDF[1:validRows,]\n  probabilitiesDF <- probabilitiesDF[1:validRows,]\n  \n  return(probabilitySeqDF)\n}",
    "created" : 1420593231756.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3450089765",
    "id" : "DBA4A6E8",
    "lastKnownWriteTime" : 1420664071,
    "last_content_update" : 0,
    "path" : "~/phd/R/2d/probSeqFunctions.R",
    "project_path" : "probSeqFunctions.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}