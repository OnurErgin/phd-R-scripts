{
    "collab_server" : "",
    "contents" : "## Have three reference nodes at one corner and generate the rest of the grid.\n\n\nfindCorner <- function (packets, cornerNodes, excludes) \n{\n  #\n  # cornerNodes[]: \n  # [1][3]\n  # [2]\n  #\n  cornerRef <- cornerNodes[1]; sideRefs <- cornerNodes[2:3]\n  winners1 <- getSendersWinningReceivers(allPackets=packets, theSender=cornerRef, excludeList=as.integer(excludes))\n  #closestNodes <- mostFreqReceiver(winners,tIndex=1)\n  \n  #winners2 <- getSendersWinningReceivers(allPackets=packets, theSender=sideRefs[1], excludeList=as.integer(excludes))\n  #winners3 <- getSendersWinningReceivers(allPackets=packets, theSender=sideRefs[2], excludeList=as.integer(excludes))\n  winners2 <- getSendersWinningReceivers(allPackets=packets, theSender=sideRefs[1], includeList=winners1[1,])\n  winners3 <- getSendersWinningReceivers(allPackets=packets, theSender=sideRefs[2], includeList=winners1[1,])\n  \n  #mostCommonReceiver <- as.integer(names(table(winners2[1,winners2[1,]%in%winners3[1,]])[1]))\n  \n  allWinners <- c(winners2[1,],winners3[1,])\n  mostFrequentReceiver <- as.integer(names(rev(sort(table(allWinners)))[1]))\n  \n  return(mostFrequentReceiver)\n}\n\ncols <- Nx <- 5; rows <- Ny <- 4; dx <- 3; dy <- 3; sd_noise_dbm <- -45\n\nTruth <- matrix (c(0:(Nx*Ny-1)), nrow=Ny, byrow=TRUE)\nrefnodes <- c(Truth[1,1],Truth[1,2], Truth[2,1])\n\nexperimentSet <- 1:100#c(3, 37, 45, 69, 84, 87)\n\n#basedirectory <- \"inputs_simulation/equiDist/3x3_ideal/\"; subdirectory<-\"\"\n#basedirectory <- \"../measurements/simOut-5x4-3mX3m-Noise-45dbm/\"; subdirectory<-\"\"\nbasedirectory <- \"./equiDist/\" # For Carme\n#basedirectory <- \"/Volumes/carme_lhome/R/2d/equiDist/\"\nsubdirectory <- paste(\"simOut-\",Nx,\"x\",Ny,\"-\",dx,\"mX\",dy,\"m-Noise\",sd_noise_dbm,\"dbm/\",sep=\"\")\ndirectory <- paste(basedirectory,subdirectory,sep=\"\")\n\npruneThreshold <- 2\nsource(\"probSeqFunctions-fixedPrune.R\")\n\ntopQuantile <- 0.5\nrssMaxDifference <- 3\n\nrun.verbose <- FALSE\nproduceOutput <- FALSE # for probabilitySeqDF and probabilitiesDF. This file will produce output anyways\n\ntotalSuccess <- 0\nfailedExpNos <- c()\n######## START\nfor(expNo in experimentSet)\n{   \n  startTime <- proc.time()\n    \n  TRACE_FILE <- paste(directory,\"2dSim-\",Nx,\"x\",Ny,\"-\",dx,\"mX\",dy,\"m-\",expNo,\".txt\",sep=\"\")\n  cat(\"Loading:\",TRACE_FILE, \"\\n\")  \n  packets <- read.table(TRACE_FILE,  na.strings=\"\", header=TRUE)\n  packets$time  <- 0\n  packets$power <- 0\n  \n  \n  result <- matrix(data=-1,nrow=rows, ncol=cols)\n  \n  result[1,1] <- Truth[1,1]\n  result[1,2] <- Truth[1,2]\n  result[2,1] <- Truth[2,1]\n  \n  \n  shortestDim <- min(dim(Truth))\n  \n  iterations <- 0\n  \n  \n  for (d in 2:shortestDim) {\n    if ( sum(result[1:d,1:d] == -1) == 1 )  # Just one -1 in the square\n    {\n      #result[d,d] <- iterations <- iterations + 1\n      cornerRef <- result[d-1,d-1]; sideRefs <- c(result[d-1,d],result[d,d-1]); \n      \n      mostCommonReceiver <- findCorner(packets, c(cornerRef,sideRefs), result)\n      \n      result[d,d] <- mostCommonReceiver\n    }\n    else {\n      iterations <- iterations + 1\n      for (rr in 1:(d-1)) # find each row\n      {\n        #result[rr,d] <- iterations # discover here\n        if (rr == 1)\n        {\n          winners <- getSendersWinningReceivers(allPackets=packets, theSender=result[rr,d-1], excludeList=as.integer(result))\n          top2winners <- as.integer(names(rev(sort(table(winners[1,])))[1:2]))\n          top2winnersP <- c(findProbabilityByName(winners[1,],top2winners[1]), findProbabilityByName(winners[1,],top2winners[2]))\n          winners2 <- getSendersWinningReceivers(allPackets=packets, theSender=result[rr,d-2], includeList=top2winners)\n          candidatesP <- c(findProbabilityByName(winners2[1,],top2winners[1])*top2winnersP[1], findProbabilityByName(winners2[1,],top2winners[2])*top2winnersP[2])\n          result[rr,d] <- top2winners[which.max(candidatesP)]\n          #result[rr,d] <- mostFreqReceiver(winners,tIndex=1)\n        }\n        else # find as corners\n        {\n          result[rr,d] <- findCorner(packets, c(result[rr-1,d-1],result[rr-1,d], result[rr,d-1]), result)\n        }\n      }\n      #iterations <- iterations + 1\n      for (cc in 1:(d-1))\n      {\n        #result[d,cc] <- iterations\n        if (cc == 1)\n        { #if(d==4) \n          #browser()\n          # Find top 3 candidates by top adjacent node\n          winners <- getSendersWinningReceivers(allPackets=packets, theSender=result[d-1,cc], excludeList=as.integer(result))\n          \n          top2winners <- as.integer(names(rev(sort(table(winners[1,])))[1:2]))\n          top2winnersP <- c(findProbabilityByName(winners[1,],top2winners[1]), findProbabilityByName(winners[1,],top2winners[2]))\n          winners2 <- getSendersWinningReceivers(allPackets=packets, theSender=result[d-2,cc], includeList=top2winners)\n          candidatesP <- c(findProbabilityByName(winners2[1,],top2winners[1])*top2winnersP[1], findProbabilityByName(winners2[1,],top2winners[2])*top2winnersP[2])\n          result[d,cc] <- top2winners[which.max(candidatesP)]\n          \n          #winners2 <- getSendersWinningReceivers(allPackets=packets, theSender=result[d-2,cc], includeList=as.integer(winners[1,]))\n          #result[d,cc] <- mostFreqReceiver(winners2,tIndex = 1)\n          if (FALSE){\n             top3winners <- as.integer(names(rev(sort(table(winners[1,])))[1:3]))\n            \n            if (d != shortestDim){ #Otherwise third candidate is equally distant from the right node\n              # Find another 2 candidates by node behind the top adjacent node\n              winners2 <- getSendersWinningReceivers(allPackets=packets, theSender=result[d-2,cc], includeList=as.integer(top3winners))\n              top2winners <- as.integer(names(rev(sort(table(winners2[1,])))[1:2]))\n              top2winners <- top2winners[!is.na(top2winners)]\n            } else{\n              \n              top2winners <- as.integer(names(rev(sort(table(winners[1,])))[1:2])) # or top3winners[1:2]\n            }\n            \n            # Find the candidate that is farther from result[d-1,cc+1] (the right adjacent node)\n            if(length(top2winners) == 1){\n              result[d,cc] <- top2winners[1]\n            } else {\n              winners3 <- getSendersWinningReceivers(allPackets=packets, theSender=result[d-1,cc+1], includeList=as.integer(top2winners))\n              NOTwinner <- mostFreqReceiver(winners3,tIndex=1)\n              \n                result[d,cc] <- top2winners[top2winners!=NOTwinner]\n              \n            }\n          }\n        }\n        else # find as corners\n        {\n          result[d,cc] <- findCorner(packets, c(result[d-1,cc-1], result[d-1,cc], result[d,cc-1]), result)\n        }\n      }\n      \n      if ( sum(result[1:d,1:d] == -1) == 1 )  # Just one -1 in the square\n      {\n        #result[d,d] <- iterations <- iterations + 1\n        cornerRef <- result[d-1,d-1]; sideRefs <- c(result[d-1,d],result[d,d-1]); \n        \n        mostCommonReceiver <- findCorner(packets, c(cornerRef,sideRefs), result)\n        \n        result[d,d] <- mostCommonReceiver\n      }\n    }\n  }\n  #Find Remaining Columns\n  longestDim <- max(dim(Truth))\n  if(FALSE) # Trying corner discovery iterations for the rest of the rows.. Apparently not good enough.\n  for (d in (shortestDim+1):longestDim){\n    for (rr in 1:shortestDim) # find each row\n    {\n      #result[rr,d] <- iterations # discover here\n      if (rr == 1)\n      {\n        winners <- getSendersWinningReceivers(allPackets=packets, theSender=result[rr,d-1], excludeList=as.integer(result))\n        top2winners <- as.integer(names(rev(sort(table(winners[1,])))[1:2]))\n        top2winnersP <- c(findProbabilityByName(winners[1,],top2winners[1]), findProbabilityByName(winners[1,],top2winners[2]))\n        winners2 <- getSendersWinningReceivers(allPackets=packets, theSender=result[rr,d-2], includeList=top2winners)\n        candidatesP <- c(findProbabilityByName(winners2[1,],top2winners[1])*top2winnersP[1], findProbabilityByName(winners2[1,],top2winners[2])*top2winnersP[2])\n        result[rr,d] <- top2winners[which.max(candidatesP)]\n        #result[rr,d] <- mostFreqReceiver(winners,tIndex=1)\n      }\n      else # find as corners\n      {\n        result[rr,d] <- findCorner(packets, c(result[rr-1,d-1],result[rr-1,d], result[rr,d-1]), result)\n      }\n    }\n  }\n  #if(FALSE)\n  for (d in (shortestDim+1):longestDim) { # Assuming, longer Dim is the Y direction\n    iterations <- iterations + 1\n    \n    for (rr in 1:shortestDim){\n      \n      if (result[rr,d] != -1)\n        next;\n      \n      #result[rr,d] <- iterations\n      winners <- getSendersWinningReceivers(allPackets=packets, theSender=result[rr,d-1], excludeList=as.integer(result))\n      candidates1 <- c(mostFreqReceiver(winners,tIndex=1),mostFreqReceiver(winners,tIndex=2))\n      candidates1P <- c(findProbabilityByName(winners[1,],candidates1[1]),findProbabilityByName(winners[1,],candidates1[2]))\n      \n      if (rr +1 <= shortestDim){ # if there is a row down below\n        winners2 <- getSendersWinningReceivers(allPackets=packets, theSender=result[rr+1,d-1], excludeList=as.integer(result))\n        candidates2 <- c(mostFreqReceiver(winners2,tIndex=1),mostFreqReceiver(winners2,tIndex=2))\n        candidates2P <- c(findProbabilityByName(winners2[1,],candidates2[1]),findProbabilityByName(winners2[1,],candidates2[2]))\n        \n      \n      if(sum(is.na(candidates1P)) == 0) # if \n        if(candidates1P[1]==candidates1P[2] ){\n          result[rr+1,d] <- candidates2[1]\n          \n          winners <- getSendersWinningReceivers(allPackets=packets, theSender=result[rr,d-1], excludeList=as.integer(result))\n          candidates1 <- mostFreqReceiver(winners,tIndex=1)\n          #candidates1P <- findProbabilityByName(winners[1,],candidate1)\n          rm(\"candidates2\")\n        }\n      }\n      result[rr,d] <- candidates1[1]\n      rm(c(\"candidates1\",\"winners\"))\n      if (FALSE)\n      {\n        if (candidate2P > candidate1P){\n          result[rr+1,d] <- candidate2\n          \n          winners <- getSendersWinningReceivers(allPackets=packets, theSender=result[rr,d-1], excludeList=as.integer(result))\n          candidate1 <- mostFreqReceiver(winners,tIndex=1)\n          candidate1P <- findProbabilityByName(winners[1,],candidate1)\n        }\n         result[rr,d] <- candidate1\n      }\n    }\n  }\n  class(result) <- \"integer\"\n  \n  if (all.equal(Truth,result) == TRUE) {\n    totalSuccess <- totalSuccess + 1\n    isSuccess <- TRUE\n  } else {\n    failedExpNos <- c(failedExpNos,expNo)\n    isSuccess <- FALSE\n    print(result)\n  }\n  cat(\"Result is \", isSuccess, \"\\t total: \",totalSuccess, \"/\",length(failedExpNos)+totalSuccess, \"\\n\")\n  \n  ## Print Elapsed Time\n  endTime <- proc.time()\n  print(endTime-startTime)\n  \n  outputToFile <- FALSE\n  outDir <- \"results-3CornerRef/\"\n  outputDirectory <- paste(directory,outDir,sep=\"\")\n  \n  if (!file.exists(outputDirectory) && outputToFile)\n    dir.create(outputDirectory,showWarnings=TRUE,recursive=TRUE)\n  \n  if(outputToFile){\n    outFile <- paste(outputDirectory,\"result-\",Nx,\"x\",Ny,\"-\",dx,\"mX\",dy,\"m-\",expNo,\".txt\",sep=\"\")\n    write.table(result, outFile, row.names=FALSE, col.names = FALSE)\n  }\n}\nif(outputToFile){\n  outFile <- paste(outputDirectory,\"success-\",Nx,\"x\",Ny,\"-\",dx,\"mX\",dy,\"m\",\".txt\",sep=\"\")\n  write.table(totalSuccess, outFile, row.names=FALSE, col.names = FALSE)\n}\ncat(\"totalSuccess=\",totalSuccess,\"/\",length(experimentSet) ,\"\\n\")\n",
    "created" : 1432828991836.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "169|40|188|2|\n",
    "hash" : "828883170",
    "id" : "C286C664",
    "lastKnownWriteTime" : 1436889214,
    "last_content_update" : 0,
    "path" : "~/phd/R/2d/equiDistance2D-3CornerRef.R",
    "project_path" : "equiDistance2D-3CornerRef.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 22,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}