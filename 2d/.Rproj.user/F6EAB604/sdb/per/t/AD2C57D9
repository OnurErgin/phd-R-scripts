{
    "collab_server" : "",
    "contents" : "## Edge Discovery Functions:\n#  Take two nodes and construct a Sequence \n\ndiscoverEdge <- function (refnodes, packets, numRows, excluding = c(), withP = FALSE) {\n  ## Discover the first column; refNodeSet\n  #browser()\n  selection_stats <- c(correct=0, total=0)\n  \n  knownNode <- refnodes[1]\n  refNodeSet <- c(knownNode)\n  P <- 1 # Empirical probability of the sequence\n  for (ri in 1:(numRows-2)){\n    # Choose two candidates at 90 degrees to each other\n    winners1 <- getSendersWinningReceivers(allPackets=packets,theSender=knownNode,excludeList=c(refNodeSet,excluding),includeList=NULL)\n    firstCandidate <- mostFreqReceiver(valueSet=winners1,tIndex=1)\n    secondCandidate <- mostFreqReceiver(valueSet=winners1,tIndex=2)\n    \n    if(refnodes[2] %in% c(firstCandidate,secondCandidate)){ # Arrived at the second reference node; with for loop this must never be TRUE\n      #refNodeSet <- c(refNodeSet, refnodes[2])\n      #print(refNodeSet)\n     ;# break\n    }\n    \n    # Choose the closest one of the two cantidates to the other refnode\n    winners2 <- getSendersWinningReceivers(allPackets=packets,theSender=refnodes[2],excludeList=NULL,includeList=c(firstCandidate,secondCandidate))\n    knownNode <- mostFreqReceiver(winners2, tIndex= 1)\n    #cat (knownNode, \"with P=\", findProbability(winners[1,], 1, length(winners[1,])),\"\\n\")\n    if (withP) \n      P <- P * findProbability(winners2[1,], 1, length(winners2[1,])) * findProbabilityByName(winners1[1,],knownNode)\n    refNodeSet <- c(refNodeSet, knownNode)\n    \n#     if (TrueRow[1] != -1) {\n#       selection_stats[\"total\"] <- selection_stats[\"total\"] + 1\n#       if (TrueRow[length(refNodeSet)] == knownNode){\n#         cat(\"Selection is Correct:\",TrueRow, \"X\", refNodeSet,\"\\n\")\n#         selection_stats[\"correct\"] <- selection_stats[\"correct\"] + 1\n#       }\n#     }\n    #print(refNodeSet)\n  }\n#print(selection_stats)\n  refNodeSet <- c(refNodeSet, refnodes[2]) # With for loop, only nodes between refnodes are discovered\n  class(refNodeSet) <- \"integer\"\n  if (withP)\n    refNodeSet <- c(refNodeSet,P)\n  return(refNodeSet)\n}\n#discoverEdge(refnodes[c(1,3)], packets, Nx)\n\ndiscoverEdge.adjacentRefNodes <- function (refnodes, packets, numRows) {\n  ## Discover the first column; refNodeSet\n  #browser()\n  knownNodes <- refnodes\n  edgeNodeSet <- c(knownNodes)\n  P <- 1\n  for (ri in 1:(numRows-2)){\n    # Choose two candidates at 90 degrees to each other\n    winners1 <- getSendersWinningReceivers(allPackets=packets,theSender=knownNodes[2],excludeList=edgeNodeSet,includeList=NULL)\n    candidates <- c(mostFreqReceiver(valueSet=winners1,tIndex=1), mostFreqReceiver(valueSet=winners1,tIndex=2))\n    \n    # Choose the closest one of the two cantidates to the other refnode\n    winners2 <- getSendersWinningReceivers(allPackets=packets,theSender=knownNodes[1],excludeList=NULL,includeList=candidates)\n    NOTnextNode <- mostFreqReceiver(winners2, tIndex= 1)\n    nextNode <- candidates[candidates != NOTnextNode][1]\n    P <- P * findProbability(winners2[1,], 1, length(winners2[1,])) * findProbabilityByName(winners1[1,],nextNode)\n    #cat (knownNode, \"with P=\", findProbability(winners[1,], 1, length(winners[1,])),\"\\n\")\n    edgeNodeSet <- c(edgeNodeSet, nextNode)\n#     if (TrueRow[1] != -1) {\n#       selection_stats[\"total\"] <- selection_stats[\"total\"] + 1\n#       if (TrueRow[length(edgeNodeSet)] == nextNode){\n#         #cat(\"Selection is Correct!\\n\")\n#         selection_stats[\"correct\"] <- selection_stats[\"correct\"] + 1\n#       }\n#     }\n    #print(refNodeSet)\n    knownNodes <- c(edgeNodeSet[length(edgeNodeSet)-1],edgeNodeSet[length(edgeNodeSet)])\n  }\n  #refNodeSet <- c(refNodeSet, refnodes[2]) # With for loop, only nodes between refnodes are discovered\n  class(edgeNodeSet) <- \"integer\"\n  edgeNodeSet <- c(edgeNodeSet,P)\n  return(edgeNodeSet)\n}\n\n##### Below function is used.\n\ngetFirstColumnRefs <- function (refnodes, packets, numRows) {\n  ## Discover the first column; refNodeSet\n  knownNode <- refnodes[1]\n  refNodeSet <- c(knownNode)\n  for (ri in 1:(numRows-2)){\n    # Choose two candidates at 90 degrees to each other\n    winners <- getSendersWinningReceivers(allPackets=packets,theSender=knownNode,excludeList=refNodeSet,includeList=NULL)\n    firstCandidate <- mostFreqReceiver(valueSet=winners,tIndex=1)\n    secondCandidate <- mostFreqReceiver(valueSet=winners,tIndex=2)\n    \n    if(refnodes[2] %in% c(firstCandidate,secondCandidate)){ # Arrived at the second reference node; with for loop this must never be TRUE\n      #refNodeSet <- c(refNodeSet, refnodes[2])\n      #print(refNodeSet)\n      break\n    }\n    \n    # Choose the closest one of the two cantidates to the other refnode\n    winners <- getSendersWinningReceivers(allPackets=packets,theSender=refnodes[2],excludeList=NULL,includeList=c(firstCandidate,secondCandidate))\n    knownNode <- mostFreqReceiver(winners, tIndex= 1)\n    #cat (knownNode, \"with P=\", findProbability(winners[1,], 1, length(winners[1,])),\"\\n\")\n    refNodeSet <- c(refNodeSet, knownNode)\n    #print(refNodeSet)\n  }\n  refNodeSet <- c(refNodeSet, refnodes[2]) # With for loop, only nodes between refnodes are discovered\n  return(refNodeSet)\n}\n\ngetFirstColumnRefs.adjacentRefNodes <- function (refnodes, packets, numRows) {\n  ## Discover the first column; refNodeSet\n  #browser()\n  knownNodes <- refnodes\n  edgeNodeSet <- c(knownNodes)\n  for (ri in 1:(numRows-2)){\n    # Choose two candidates at 90 degrees to each other\n    winners <- getSendersWinningReceivers(allPackets=packets,theSender=knownNodes[2],excludeList=edgeNodeSet,includeList=NULL)\n    candidates <- c(mostFreqReceiver(valueSet=winners,tIndex=1), mostFreqReceiver(valueSet=winners,tIndex=2))\n    \n    # Choose the closest one of the two cantidates to the other refnode\n    winners <- getSendersWinningReceivers(allPackets=packets,theSender=knownNodes[1],excludeList=NULL,includeList=candidates)\n    NOTnextNode <- mostFreqReceiver(winners, tIndex= 1)\n    nextNode <- candidates[candidates != NOTnextNode][1]\n    #cat (knownNode, \"with P=\", findProbability(winners[1,], 1, length(winners[1,])),\"\\n\")\n    edgeNodeSet <- c(edgeNodeSet, nextNode)\n    #print(refNodeSet)\n    knownNodes <- c(edgeNodeSet[length(edgeNodeSet)-1],edgeNodeSet[length(edgeNodeSet)])\n  }\n  #refNodeSet <- c(refNodeSet, refnodes[2]) # With for loop, only nodes between refnodes are discovered\n  return(edgeNodeSet)\n}\n",
    "created" : 1432766588988.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4177176946",
    "id" : "AD2C57D9",
    "lastKnownWriteTime" : 1436534611,
    "last_content_update" : 0,
    "path" : "~/phd/R/2d/EdgeDiscovery.R",
    "project_path" : "EdgeDiscovery.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 21,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}