{
    "collab_server" : "",
    "contents" : "## 21.11.2014\n\nsource(\"./probSeqFunctions.R\")\n\n\nmyprint <- function (..., level=0, debugLevel = 1, separator=\" \")\n{\n  wholestring <- list(...)\n  main_print <- paste(wholestring,sep=separator) # convert to 'cat()' printable string\n  foreprint <- paste(\"<\",level,\">\",sep=\"\")\n  if (level >= debugLevel)\n    cat(foreprint, main_print,\"\\n\", sep=separator)\n}\ntopDebugLevel <- 0\n\n\ntwoBy10 <- 0:19\n#twoBy7 <- c(151, 153,12,10,149,147,89,88,144,145,93,92,139,141)\nTruth <- matrix(twoBy10,nrow=2,ncol=length(twoBy10)/2, byrow=TRUE)\nrefnode <- twoBy10[1]\n\ntopQuantile <- 1\nrssMaxDifference <- 0\nrefnode <- 0\n\nfile <- \"2dSim-10x2-1.txt\"\n\npackets <- read.table (file, header=TRUE)\npackets$time  <- 0\npackets$power <- 0\nhead(packets)\n\n#winningReceivers <- getSendersWinningReceivers(packets,theSender=0,includeList=Truth)[\"receiver\",]\n#max(table(winningReceivers))\n\n#maxReceiver <- mostFreqReceiver(winningReceivers,1)\n#maxReceiverProb <- findProbability(winningReceivers,maxReceiver,length(winningReceivers[!is.na(winningReceivers)]))\n\n\nnodeseq <- c()\nnextnode <- refnode\nnodeseq <-c(nodeseq, nextnode)\n\nwinningReceivers <- getSendersWinningReceivers(packets,theSender=refnode,includeList=Truth)[\"receiver\",]\nnode1 <- mostFreqReceiver(winningReceivers,1)\nnode2 <- mostFreqReceiver(winningReceivers,2)\nnodeseq <-c(nodeseq, node1); nodeseq <-c(nodeseq, node2) #add nodes to nodeseq\nmyprint(nodeseq,level=0,debugLevel=topDebugLevel)\n\nfor  (i in 1:10)\n{\n  \n  #if (length(nodeseq)==length(Truth)) break;\n\n  myprint(i,level=0,debugLevel=topDebugLevel)\n  winners <-c()\n  \n  node1WinnersList <- getSendersWinningReceivers(packets,node1,excludeList=nodeseq)[\"receiver\",]\n  node1Winners <- c(mostFreqReceiver(node1WinnersList,1), mostFreqReceiver(node1WinnersList,2))\n  \n  node2WinnersList <- getSendersWinningReceivers(packets,node2,excludeList=nodeseq)[\"receiver\",]\n  node2Winners <- c(mostFreqReceiver(node2WinnersList,1), mostFreqReceiver(node2WinnersList,2))\n  \n  winners <- c(node1Winners,node2Winners)\n  winners <- winners[!is.na(winners)]\n  if(length(unique(winners)) <= 1) #last node\n  {\n    if (length(unique(winners)) != 0)\n    {\n      nodeseq <- c(nodeseq,winners[1]) #add last node\n      myprint(nodeseq,level=1,debugLevel=topDebugLevel)\n    }\n    break;\n  }else\n  {\n    winnerFreq <- table(winners)\n    if (max(winnerFreq) > 1)\n    {\n      closestCornerNode <- as.numeric(names(which.max(winnerFreq)))\n    }else #ask the previous node\n    {\n      previousNode <- nodeseq[length(nodeseq)-2]\n      \n      closestCornerNodeList <- getSendersWinningReceivers(packets, previousNode, includeList=winners)[\"receiver\",]\n      closestCornerNode <- mostFreqReceiver(closestCornerNodeList,1)\n      myprint(node1,\" and \",node2,\" asked the previous node:\", previousNode, level=1, debugLevel=topDebugLevel)\n      \n    }\n    nodeseq <- c(nodeseq,closestCornerNode) #add\n    \n    oldnode <- nodeseq[length(nodeseq)-3] # at the opposite corner of last couple\n  \n    \n    #diagonalNode <- getClosestIn(oldnode, all_stats, winners[winners!=closestCornerNode], constraint, 1)\n    diagonalNodeList <- getSendersWinningReceivers(packets,oldnode,includeList=winners[winners!=closestCornerNode])[\"receiver\",]\n    diagonalNode <- mostFreqReceiver(diagonalNodeList,1)\n    \n    \n    nodeseq <- c(nodeseq, diagonalNode) #add\n    myprint(nodeseq,level=0,debugLevel=topDebugLevel)\n    \n    \n    \n  } #last node\n  \n  node1 <- nodeseq[length(nodeseq)]\n  node2 <- nodeseq[length(nodeseq)-1]\n  \n} \nprint (matrix(as.integer(nodeseq),nrow=2, byrow=FALSE))\nresultSeq <- matrix(nodeseq,nrow=2,ncol=length(Truth)/2, dimnames=list(c(1:2),c(1:10)))\n\nError<- matrix(rep(0,nrow(Truth)*ncol(Truth)),nrow=nrow(Truth), ncol=ncol(Truth)) # Comparison matrix\n#A<- matrix(as.character(Truth == resultSeq),nrow=nrow(Truth), ncol=ncol(Truth)) # Comparison matrix\n#A[A==\"TRUE\"]<-\"\"\n#A[A==\"FALSE\"]<-\"F\"\n\nfor (r in 1:nrow(Truth))\n  for(c in 1:ncol(Truth))\n  {\n    resultLoc <- which(resultSeq==Truth[r,c], arr.ind=TRUE)\n    diffRow <- abs(resultLoc[1,\"row\"]-r)\n    diffCol <- abs(resultLoc[1,\"col\"]-c)\n    Error[r,c] <- sum(diffRow, diffCol)\n  }\nprint(Error)\n\n###\n#1-D Sequence: !! If there is one and only one shortest path from the reference node to any other node, it will work. \nsource(\"2D-SimulatedNodes.R\")\npackets <- as.data.frame(measurements)\npackets$time  <- 0\npackets$power <- 0\n\nwinningReceivers <- getSendersWinningReceivers(packets,theSender=0,includeList=Truth)[\"receiver\",]\nb<-table(winningReceivers)\n#b <- as.numeric(unlist(dimnames(b)))\n#a <- subset(packets, sender==0 & receiver %in% b)\n#a[with(a,order(rssi)),]\n\nprint(\"Finding Sequence\")\nrefnode <- 0\nmaxSubSeqSize <- 3\nnumnodes <- length(Truth)\nprobabilitySeqDF <- findProbSequences(packets,refnode, produceOutput=FALSE, verbose=TRUE);\nprobOrder <- with(probabilitySeqDF,order(-prob))\nprobabilitySeqDF <- probabilitySeqDF[probOrder,]\n\n## RESULT\nprint(probabilitySeqDF[1,])\nwinnerSeq <- probabilitySeqDF[1,1:numnodes] ; winnerSeq <- as.integer(unlist(winnerSeq))\n\nresultGrid <- matrix(winnerSeq, nrow=Ny, byrow=TRUE)\n\n# reverse Even Rows\nfor(r in 1:Ny){\n  if(r %% 2 == 0)\n    resultGrid[r,] <- rev(resultGrid[r,])\n}\n\nverdict <- all(resultGrid == Truth)\ncat(\"Verdict is:\", verdict,\"\\n\");\n",
    "created" : 1416488857503.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1532358120",
    "id" : "EBF53FCD",
    "lastKnownWriteTime" : 1417193964,
    "last_content_update" : 0,
    "path" : "~/phd/R/2d/2d-probabilistic.R",
    "project_path" : "2d-probabilistic.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}