{
    "collab_server" : "",
    "contents" : "## probabilisticSeq.R - O.Ergin - 17.06.2013\n# v2 - 14.08.2013\n# Description ...\n# \tThis one clusters sequences in subsequences of n. After n'th node in the sequence, the best one is taken and iterated from there to the end.\n# \tIt should be after every n'th node after the beginning or last cropping, but for our case (max node=10) this is not necessary <== resolved\n\n# In addition, it doesn't only select the first winning node, but also other nodes with up to 2dbm difference for selecting Winning receivers.\n#\n# Version History: \n#\n# v2.1 - 30.10.2013\n#\tTree will be clustered with the paths whose P's are equal or greater than maximum P\n#\tClustering is now every maxSubSeqSize mod of the path length\n#\n# v2.2 - 19.11.2013\n#\tpackets is subsetted to Truth list, for the case there are more nodes in the measurement than desired.\n#\n# v2.3 - 05.12.2013\n# Last remaining node is now assigned a heuristical probability by the last placed node, compared with the two nodes previously placed node\n#\n# v.2.5 - 23.05.2014\n# Check the verdict with the reverse sequence\n#\n# For best maxRankToCompare sequences, compute the reverse maxRankToCompare Sequences\n# Check for consistency\n#\n# DONE ToDo: Convert the sequence building algorithm into a function, with parameters (packets, refnode) \n#\n\n#library(tcltk)\n\n## Load configuration file\n## global/common variables are written \n## in a configuration file now.\n\nsource(\"probSeqFunctions.R\")\n\ndebugging <- FALSE\nproduceOutput <- FALSE\n\nmaxSubSeqSize <- 4\ntopQuantile <- 0.50\nrssMaxDifference <- 0\n\nrun.verbose <- TRUE\n\n#TRACE_FILE <- \"today6.txt\"\n#Truth <- c(100, 369, 367, 368, 333, 357, 334, 363)\nTRACE_FILE <- \"studentPorject_inputs/lowpower7.txt\"\nTruth <- c(3, 359, 356, 363, 5, 368, 333, 4, 369, 365, 2, 334)\n\nrefnode <- Truth[1]\nnumnodes <- length (Truth)\n\ntotalSuccess <- 0\n \n#experimentSet <- 15\n#probsOutputDirectory <- outputDirectory\n#outputDirectory <- \"verify/\"\n\n\nfor(expNo in 1)\n{   \n\tstartTime <- proc.time()\n\t\n\t\n\t\n\tif (\"packets\" %in% ls() && debugging) {\n\t\t; # do not reload packets\n\t}\n\telse # not debugging\n\t{\n\t\tcat(\"Loading:\",TRACE_FILE, \"\\n\")\t\n\t\tpackets <- read.table(TRACE_FILE, sep=\"\\t\", na.strings=\"\", col.names=c(\"receiver\", \"sender\", \"channel\", \"rssi\", \"power\", \"time\", \"packetnum\"), colClasses=c(rep(\"factor\",3), \"numeric\", \"factor\", \"character\", \"numeric\"), header=FALSE)\n\t}\n\t#packets <- subset(packets, sender %in% Truth & receiver %in% Truth)\n  packets <- droplevels(packets)\n  numnodes <- length(unique(packets$sender))\n  \n\t## DEBUG SET\n\tif (debugging) {\n\t\tprint(\"Debug set.\")\n\t\tpackets <- subset(packets,receiver %in% debugSet & sender %in% debugSet)\n\t}\n\t\n# \tanalyse <- matrix(data = NA, nrow = 4, ncol = 11, byrow = TRUE, dimnames = list(NULL,c(\"expNo\", \"Rank\", \"isCorrect\", \"prob\", \n#                                                                                          \"verifyRank\", \"verifyIsCorrect\", \"verifyProb\", \n#                                                                                          \"match\", \"JointProb\", \"ComputedSeq\", \"verifySeq\")))\n\n    analyse <- data.frame(expNo=integer(), Rank=integer(), isCorrect=logical(), prob=double(),\n                          verifyRank=integer(), verifyIsCorrect=logical(), verifyProb=double(), \n                          match=logical(), jointProb=double(), computedSeq=character(), verifySeq=character(),\n                          stringsAsFactors=FALSE)\n\n  print(\"Finding Sequence\")\n\tprobabilitySeqDF <- findProbSequences(packets,refnode, produceOutput=produceOutput, verbose=run.verbose);\n    probOrder <- with(probabilitySeqDF,order(-prob))\n    probabilitySeqDF <- probabilitySeqDF[probOrder,]\n  \n\t## RESULT\n\tprint(probabilitySeqDF[1,])\n\twinnerSeq <- probabilitySeqDF[1,1:numnodes] \n\tverdict <- all(winnerSeq == Truth)\n\tcat(\"Verdict is:\", verdict,\"\\n\"); \n  \nmaxRankToCompare <- 2\nfor (mainRank in 1:maxRankToCompare)\n{\n  cat(\"Verify\", mainRank,\"\\n\")\n\tverifySeqDF <- findProbSequences(packets,refnode=probabilitySeqDF[mainRank,numnodes], produceOutput=produceOutput, verbose=run.verbose);\n    probOrder <- with(verifySeqDF,order(-prob))\n    verifySeqDF <- verifySeqDF[probOrder,]\n  cat(\"Verify\", mainRank,\"is\", all(rev(verifySeqDF[1,1:numnodes])==Truth), \"\\n\" )\n  \n  for (verifyRank in 1:maxRankToCompare) \n  {\n    i <- (mainRank-1)*maxRankToCompare+verifyRank;\n    \n  \tanalyse[i,\"expNo\"] <- expNo; \n    \n    analyse[i,\"Rank\"] <- mainRank; \n    analyse[i,\"isCorrect\"] <- all(probabilitySeqDF[mainRank,1:numnodes] == Truth); \n    analyse[i,\"prob\"] <- probabilitySeqDF[mainRank,\"prob\"];\n  \n  \tanalyse[i,\"verifyRank\"] <- verifyRank; \n    analyse[i,\"verifyIsCorrect\"] <- all(rev(verifySeqDF[verifyRank,1:numnodes])==Truth); \n    analyse[i,\"verifyProb\"] <- verifySeqDF[verifyRank,\"prob\"];\n  \n    analyse[i,\"match\"] <- all(probabilitySeqDF[mainRank,1:numnodes] == rev(verifySeqDF[verifyRank,1:numnodes]));\n    analyse[i,\"jointProb\"] <- probabilitySeqDF[mainRank,\"prob\"] * verifySeqDF[verifyRank,\"prob\"];\n  \n    analyse[i,\"computedSeq\"] <- paste(probabilitySeqDF[mainRank,1:numnodes], collapse=\",\");\n    analyse[i,\"verifySeq\"] <- paste(verifySeqDF[verifyRank,1:numnodes],collapse=\",\");\n  }\n}\n\t## Print Elapsed Time\n\tendTime <- proc.time()\n\tprint(endTime-startTime)\n\t\n\tif(verdict == TRUE)\n\t{\n\t\ttotalSuccess <- totalSuccess +1\n\t}\n\tcat(\"TotalSUCCESS=\",totalSuccess,\"\\n\");\n\t\n\tprint(analyse)\n  #write.table(analyse, file=outputFileName, sep=\" \", append=TRUE, col.names=(expNo==experimentSet[1]), row.names=FALSE)\n\tif (TRUE)\n  {\n  \trm(packets)\n\t}\n} # for expNo\n\nmatches <- subset(analyse, match == TRUE)\nif (nrow(matches) == 0 ) matches <- analyse\nmaxMatch <- which.max(matches$prob)\nresult <- matches[maxMatch,]$computedSeq\n\ncat (\"The result is: \", matches[maxMatch,]$isCorrect, \" => \",result ,\"\\n\")\n\n# Run: Rank Verdict prob RankCheck VerdictCheck ProbCheck\n# n     1    T/F     p1    1         T/F          pc1\n# n     1    T/F     p1    2         T/F          pc2\n# n     2    T/F     p1    1         T/F          pc1\n# n     2    T/F     p1    2         T/F          pc2\n# \n# expNo: Rank Verdict prob RankCheck VerdictCheck ProbCheck Same JointProb ComputedSeq CheckSeq\n#   n     1    F       p1    1         T          pc1         F   \n#   n     1    F       p1    2         F          pc2         ?\n#   n     2    T       p1    1         T          pc1         T\n#   n     2    T       p1    2         F          pc2         F\n",
    "created" : 1425050693767.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2493296924",
    "id" : "22BAA865",
    "lastKnownWriteTime" : 1427472824,
    "last_content_update" : 0,
    "path" : "~/phd/R/probabilisticSeq/Student_Proj_probabilisticSeq-v2.5.R",
    "project_path" : "Student_Proj_probabilisticSeq-v2.5.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}